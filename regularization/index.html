<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Learn how to appropriately initialize parameters in your neural networks.">
    <meta name="author" content="--">
    <title>Regularization</title>
    <!-- Fonts -->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Assistant:300,400,600,700" rel="stylesheet">

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
    <!-- Home Page CSS -->
    <link rel="stylesheet" type="text/css" href="../css/template.css">
    <!--Favicon-->
    <link rel="shortcut icon" type="image/png" href="../img/favicon.png" />
    <!-- Load jquery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Load D3 -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!--Tool Tip-->
    <script src="../js/d3.tip.js"></script>
    <!-- Load Tensorflow -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3/dist/tf.min.js"></script>
    <!-- Load Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.js" integrity="sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq" crossorigin="anonymous"></script>
    <!-- Load Highlight -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/monokai-sublime.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <!--Scroll To-->
    <script src="../js/template.js"></script>
</head>

<body>
    <div class="header">
        <div class="header-wrapper">

        	<a href="https://www.deeplearning.ai/"><img id="header-logo" class="cppnControl" src="../img/deeplearning.png"></a>
            <a href="../index.html" class="backToBlog">AI Notes</a>
            <ul class="header-nav">
                <li id="current_article">Regularization</li>
                <li><a href="../initialization/index.html">Initialization</a></li>
                <li><a href="../optimization/index.html">Optimization</a></li>
            </ul>
        </div>
    </div>
    <div class="main vis-background">
        <div class="container" >
            <div class="column-6-8 column-align" >
                <h1 class="title">Regularizing your neural networks</h1>
            </div>
        </div>

    </div>
    <div class="main intro ">
        <div class="container divider-bottom" >
            <div class="column-6-8 column-align" >

                <h2 class="title">Regularization methods are used to prevent your model from overfitting on the training data in order to better generalize to unseen data. In this post, you will learn various methods to regularize your models. Our recommendations will be accompanied by intuitive explanations and interactive visualizations.</h2>

            </div>

            <div class="column-2-8 column-align">
                <h3 class="tableOfContent">Table of content</h3>
                <ol class="tableOfContent" type="I">
                    <li class="index index1">The importance of regularization</li>
                    <li class="index index2">Early stopping</li>
                    <li class="index index3">L1 and L2 regularizations</li>
                    <li class="index index4">Dropout regularization</li>
                </ol>
            </div>
        </div>
    </div>

    <div class="main">
        <div class="container index1-target">
            <div class="column-6-8 column-align">
                <h3>I&emsp;The importance of regularization</h3>
                <p>Ultimately, you want your neural network to generalize to “unseen data” so that it can be used in the real world. A neural network's ability to generalize to unseen data depends on two factors:
                </p>
                <ul>
                    <li>The information in the training data. For example, a dataset of images taken from the front-facing camera of a car contains intuitively more complex information than a dataset of images of clouds in the sky.</li>
                    <li>The complexity of the network. By complexity, we mean the complexity of the function your neural network can mimic. Usually, the more parameters your network uses, the more complex it is.</li>
                </ul>
            </div>
            <div class="column-6-8">
                <h4>Case 1: The network is not complex enough, and the training data contains a lot of information.</h3>
            </div>
            <div class="column-6-8 column-align">
                <p>Your network is too simple to understand the training data’s salient features. This is called <span class="marginanchor" id="margin-0-anchor" data-number="0" data-align="middle">underfitting</span> the training set.</p>
                <p class="inline-caption"><b>Example:</b> You train a 2-layer convolutional neural network on an ImageNet classification task (1000 classes that are very different from each other.)</p>
                <p>Here’s a common trick to avoid underfitting: deepen your neural network by adding more layers.</p>
            </div>
            <div class="column-2-8 column-align margin">
            	<div class="marginbody" id="margin-0-body" data-number="0">
                    <img src="img/underfit.png">
                	<p class="caption">An underfit classifier will learn a simple decision boundary (red line) that fails to capture the structure of the training data resulting in many misclassified training points.</p>
                </div>
            </div>
            <div class="column-6-8">
                <h4>Case 2: The network is very complex, but the training data doesn’t contain too much information.</h3>
            </div>
            <div class="column-6-8 column-align">
                <p>Your network is <span class="marginanchor" id="margin-1-anchor" data-number="1" data-align="middle">complex</span> enough to fully memorize the mapping between the training data and the training labels. However, it does not generalize well to unseen data because it has merely over-memorized the salient features of the training set. This is called <span class="marginanchor" id="margin-2-anchor" data-number="2" data-align="middle">overfitting</span> the training set.</p>
                <p class="inline-caption"><b>Example 1:</b> You train a 20-layer convolutional neural network to detect if there’s a cloud (label 1) or no clouds (label 0) in the sky.</p>
                <p class="inline-caption"><b>Example 2:</b> Consider a “day vs. night image classification”. Rather than understanding the <span class="marginanchor" id="margin-8-anchor" data-number="8" data-align="middle">inherent features</span> of the data such as the brightness, the colors or the presence of a blue sky, your model learned mapping between training images and training labels by heart. You do not want this.</p>
                <p>The best way to help your model generalize is to gather a larger dataset, but this is not always possible. When you do not have access to a large dataset, you can use regularization methods. Let’s learn the intuition behind these methods.</p>
            </div>
            <div class="column-2-8 column-align margin">
                <div class="marginbody" id="margin-1-body" data-number="1">
                    <p class="caption">The number of parameter (weights) is usually a proxy to measure the complexity of a network.</p>
                </div>
                <div class="marginbody" id="margin-2-body" data-number="2">
                    <img src="img/overfit.png">
                    <p class="caption">An overfit classifier will learn a complex decision boundary (red line) that correctly classifies most of the training data, but will not generalize to unseen data.</p>
                </div>
                <div class="marginbody" id="margin-8-body" data-number="8">
                    <p class="caption">What are the hints telling us that the image was taken during the day or the night?</p>
                </div>
            </div>
            <div class="column-6-8">
                <h4>Data Split: partioning a data set.</h4>
            </div>
            <div class="column-6-8 divider-bottom column-align">
                <p>Before we explore the main regularization methods, you must partition your dataset. In order to estimate the ability of your model to generalize, you will split your dataset into three (or sometimes more) sets: <span class="marginanchor" id="margin-3-anchor" data-number="3" data-align="middle">training</span>, <span class="marginanchor" id="margin-4-anchor" data-number="4" data-align="middle">dev</span> and <span class="marginanchor" id="margin-5-anchor" data-number="5" data-align="middle">test</span>. If your model is trained on the training set, tuned on the dev set, and still performs well on the test set, it is able to generalize successfully.</p>
                <table>
                  <tr>
                    <th>Train Accuracy</th>
                    <th>Dev Accuracy</th>
                    <th>Test Accuracy</th>
                    <th>Conclusion</th>
                  </tr>
                  <tr>
                    <td>99%</td>
                    <td>75%</td>
                    <td>70%</td>
                    <td>Overfitting (high variance)</td>
                  </tr>
                  <tr>
                    <td>88%</td>
                    <td>85%</td>
                    <td>83%</td>
                    <td>Underfitting (high bias)</td>
                  </tr>
                  <tr>
                    <td>95%</td>
                    <td>93%</td>
                    <td>92%</td>
                    <td><span class="marginanchor" id="margin-45-anchor" data-number="45" data-align="middle">Appropriate</span> (correct bias/variance trade-off)</td>
                  </tr>
                </table>
                <p>You want to close the performance gap between your test set and your dev and training set while keeping the training performance as high as possible. Let’s delve into the methods that will help you do so.</p>
            </div>
            <div class="column-2-8 column-align margin">
                <div class="marginbody" id="margin-3-body" data-number="3">
                    <p class="caption">The data used to train your model.</p>
                </div>
                <div class="marginbody" id="margin-4-body" data-number="4">
                    <p class="caption">The data used to tune the hyperparameters of your model. This is sometimes referred to as a "validation" set.</p>
                </div>
                <div class="marginbody" id="margin-5-body" data-number="5">
                    <p class="caption">The data used to evaluate the performance of your model in real life.</p>
                </div>
                <div class="marginbody" id="margin-45-body" data-number="45">
                    <img src="img/appropriate.png">
                    <p class="caption">An appropriate classifier will learn a decision boundary (red line) that correctly classifies most of the training data, and will generalize to unseen data.</p>
                </div>
            </div>
        </div>
        <div class="container">
            <div class="column-6-8 index2-target column-align">
                <h3>II&emsp; Early stopping</h3>
                <p>One of the widely used regularization method is called early stopping. Recall that <span class="marginanchor" id="margin-6-anchor" data-number="6" data-align="middle">optimizing</span> a network to find the correct parameters is an iterative process. If you evaluate your model’s error on the training and dev set after every training epoch, you might see such curves:</p>
                <!-- <object type="image/svg+xml" data="img/earlystopping.svg">
                  <img src="img/curves.png">
                </object> -->
                <div id="earlystopping-placeholder"></div>
                <p>Based on this observation, you can estimate that after the 30,000th <span class="marginanchor" id="margin-7-anchor" data-number="7" data-align="middle">epoch</span>, your model starts overfitting to the training set. Early stopping means saving the model’s parameters at the 30,000th epoch. The saved model is the best performing model on the dev set and will likely generalize better to the test set.</p>
            </div>
            <div class="column-2-8 column-align margin">
                <div class="marginbody" id="margin-6-body" data-number="6">
                    <p class="caption">Examples of optimizations are Stochastic Gradient Descent, Adam, Momentum or RMS Prop.</p>
                </div>
                <div class="marginbody" id="margin-7-body" data-number="7">
                    <p class="caption">An epoch is one optimization pass over the entire dataset. In full-batch gradient descent, one epoch is one iteration, but in stochastic gradient descent, one epoch is multiple iterations.</p>
                </div>
            </div>
            <div class="column-6-8">
                <h4>What are the main advantages of early stopping?</h4>
            </div>
            <div class="column-6-8 divider-bottom column-align">
                <ul>
                    <li>It is usually easier to do. Deep learning frameworks, such as Tensorflow or Pytorch, offer options to save your model’s parameters regularly during training. In real world applications, determining when a chosen quantity (e.g. validation accuracy) has stopped improving is sometimes hard due to noisy batches of data. Here's a Python code walking through a possible implementation of early stopping.</li>
                    <pre><code class="python">
def early_stopping(model, X_train, Y_train, X_dev, Y_dev, eval_freq = 1, stop_wait = 100):
    """
    Python implementation of the early stopping algorithm.

    Arguments:
    model -- Your model class which comes with functions:
                model.train() -- trains the model for one step and returns the updated model.
                model.eval() -- evaluates the model on a set and returns the error.
                model.copy() -- copies the model.
    X_train -- Training set
    Y_train -- Training labels
    X_dev -- Dev set
    Y_dev -- Dev labels
    eval_freq -- integer, ratio of training step per evaluation step.
    stop_wait -- number of train step without dev error improvement before stopping.

    Returns:
    best_model -- the model with minimal dev error and early stopping
    best_dev_error -- the best dev error achieved by best_model
    best_model_index -- the best_model's saving step
    """

    current_model = model.copy()       # Track your current model
    best_model = model.copy()          # Track your best model
    num_train_steps = 0                # number of training steps
    num_steps_since_best_model = 0     # number of training steps since the last best model was saved
    best_dev_error = np.inf            # the best dev error achieved so far (by best_model)
    best_model_index = 0               # the best_model's saving step

    # Loop unless there's no model improvement on the dev set for stop_wait steps.
    while num_steps_since_best_model < stop_wait:

        # Train current_model for "train_per_eval_ratio" steps
        for s in range(train_per_eval_ratio):
            current_model.train(X_train, Y_train)
            num_train_steps = num_train_steps + 1

        # Evaluate your current_model on the dev set.
        dev_error = current_model.eval(X_dev, Y_dev)

        # If the dev error is lower than the best dev error previously achieved, then save the current_model as the best_model
        if dev_error < best_dev_error:
            num_steps_since_best_model = 0
            best_model = current_model.copy()
            best_model_index = num_train_steps
            current_model = best_model
        # Otherwise increment num_steps_since_best_model
        else:
            num_steps_since_best_model = num_steps_since_best_model + 1

        return best_model, best_dev_error, best_model_index
                    </code></pre>
                    <li>It is quicker than other regularization methods because you do not have any regularization hyperparameter to tune. In comparison, L2 regularization requires you to tune a regularization hyperparameter. It might take you several experiments to regularize your model with L2, while early stopping only needs one run.</li>
                </ul>

        <p>
            Despite being practical, early stopping is not satisfying from a scientific standpoint. There exist other regularization methods, such as L1 (/L2) regularization and dropout, or optimization methods, such as learning rate annealing, that rely more on theory and are often more reliable.
        </p>
            </div>
        </div>

        <div class="container">
            <div class="column-6-8 index3-target">
                <h3>III&emsp; L1 and L2 regularizations</h3>
                <p>In order to avoid overfitting the training set, you can try to reduce the complexity of the model by removing layers, and consequently decreasing the number of parameters. As shown by the work of <a href="https://papers.nips.cc/paper/563-a-simple-weight-decay-can-improve-generalization.pdf" target="_blank">Krogh and Hertz (1992)</a>, another way to constrain a network and lower its complexity is to:</p>
                <p class="inline-caption">Limit the growth of the weights through some kind of weight decay.</p>
                <p>You want to prevent the weights from growing too large, unless it is really necessary. Intuitively, you are reducing the set of potential networks to choose from. </p>
            </div>
            <div class="column-6-8">
                <h4>How does this work?</h4>
            </div>
            <div class="column-6-8 divider-bottom column-align">
                <p>L1 and L2 regularizations can be achieved by simply adding a term that penalizes large weights to the cost function. If you were training a network to minimize the cost <script> document.write(katex.renderToString('J_{cross-entropy} = - \\frac{1}{m}\\sum_{i=1}^m y^{(i)}log(\\hat{y}^{(i)})'))</script> with (let’s say) gradient descent, your weight update rule would be:</p>
                <script>
	                var render = katex.renderToString("w = w - \\alpha \\frac{\\partial J_{cross-entropy}}{\\partial w}", { displayMode: true });
	                document.writeln(render);
                </script>
                <p>Instead, you would now train a network to minimize the cost <script> document.write(katex.renderToString('J_{regularized} = J_{cross-entropy} + \\lambda J_{\\text{L1 or L2}}'))</script> where <script> document.write(katex.renderToString('J_{L1} = \\sum_{\\text{all weights } w_k} |w_k|'))</script> and <script> document.write(katex.renderToString('J_{L2} = ||w||_2^2 = \\sum_{\\text{all weights } w_k} |w_k|^2'))</script>. Your weight update rule would be:</p>
                <script>
	                var render = katex.renderToString("w = w - \\alpha \\frac{\\partial J_{regularized}}{\\partial w} = w - \\alpha ( \\frac{\\partial J_{cross-entropy}}{\\partial w} + \\lambda \\frac{\\partial J_{L1 or L2}}{\\partial w} )", { displayMode: true });
	                document.writeln(render);
                </script>
                <p>For <span class="marginanchor" id="margin-9-anchor" data-number="9" data-align="middle">L1 regularization</span>, this would lead to the update rule:</p>
            	<script>
	                var render = katex.renderToString("w = w - \\underbrace{\\alpha \\lambda sign(w)}_\\text{L1 penalty} - \\underbrace{\\alpha \\frac{\\partial J_{cross-entropy}}{\\partial w}}_\\text{Gradient penalty}", { displayMode: true });
	                document.writeln(render);
                </script>
                <p>For <span class="marginanchor" id="margin-10-anchor" data-number="10" data-align="middle">L2 regularization</span>, this would lead to the update rule:</p>
                <script>
                    var render = katex.renderToString("w = w - \\underbrace{2 \\alpha \\lambda w}_\\text{L2 penalty} - \\underbrace{\\alpha \\frac{\\partial J_{cross-entropy}}{\\partial w}}_\\text{Gradient penalty}", { displayMode: true });
                    document.writeln(render);
                </script>
                <p>At every step of L1 and L2 regularization the weight is pushed to a slightly lower value because <script> document.write(katex.renderToString('2 \\alpha \\lambda << 1'))</script>, causing weight decay.</p>
            </div>
            <div class="column-2-8 column-align margin">
                <div class="marginbody" id="margin-9-body" data-number="9">
                    <p class="caption">In statistics, a linear regression with L1 regularization is sometimes referred to as Lasso regression.</p>
                </div>
                <div class="marginbody" id="margin-10-body" data-number="10">
                    <p class="caption">In statistics, a linear regression with L2 regularization is sometimes referred to as Ridge regression.</p>
                </div>
            </div>
            <div class="column-6-8">
                <h4>What’s the difference between L1 and L2?</h4>
            </div>
            <div class="column-6-8 column-align">
                <p>The update rules are different. While the L2 “weight decay” <script> document.write(katex.renderToString('2 \\alpha\\lambda w'))</script> penalty is proportional to the value of the weight to be updated, the L1 “weight decay” <script> document.write(katex.renderToString('\\alpha\\lambda sign(w)'))</script> is not.</p>
                <p>For L2, the smaller the <script> document.write(katex.renderToString('w'))</script>, the smaller the penalty during the update of <script> document.write(katex.renderToString('w'))</script> and vice-versa for larger <script> document.write(katex.renderToString('w'))</script>.</p>
                <p>For L1, the penalty is independent of the value of <script> document.write(katex.renderToString('w'))</script>, but the direction of the penalty (positive or negative) depends on the sign of <script> document.write(katex.renderToString('w'))</script>. This results in an effect called “feature selection” or “weight sparsity”. L1 regularization makes the non-relevant weights 0.</p>
                <p>You can play with the visualization below to see the impact of L1 and L2 regularization on the weights during training.</p>
            </div>
        </div>

        <div class="full-container hide-backToTop" id="mnist">
            <div class="viz-column-4-8">
                <div id="mnist_network"></div>
            </div>
            <div class="viz-column-4-8">
                <p class="viz-field">Use the following selections to view a histogram of the weight values <span id="regularized"
                class="bold">with</span> and <span id="unregularized" class="bold">without</span> regularization.</p>
            	<div class="viz-field">
                    <h4>1. Select a regularization method</h4>
                	<label class="radio-container">L1 regularization
                        <input type="radio" value="1" name="mnist_init" checked>
                        <span class="checkmark"></span>
                    </label>
                    <label class="radio-container">L2 regularization
                        <input type="radio" value="0" name="mnist_init">
                        <span class="checkmark"></span>
                    </label>
                </div>
                <div class="viz-field">
                    <h4>2. Choose a value for the regularization constant</h4>
                    <p class="viz-field">Choose a value for <script> document.write(katex.renderToString('\\lambda'))</script> in the update equations above.</p>
                    <label class="radio-container">Too small
                        <input type="radio" value="0.00001" name="lambda_sparsity">
                        <span class="checkmark"></span>
                    </label>
                    <label class="radio-container">Appropriate
                        <input type="radio" value="0.01" name="lambda_sparsity" checked>
                        <span class="checkmark"></span>
                    </label>
                    <label class="radio-container">Too large
                        <input type="radio" value="1" name="lambda_sparsity">
                        <span class="checkmark"></span>
                    </label>
                </div>
                <div class="viz-field">
                    <h4>3. Load your dataset and train the network</h4>
                    <p class="viz-field">Load data and train both <span id="regularized" class="bold">regularized</span> and <span id="unregularized" class="bold">unregularized</span> networks.</p>
                    <div class="viz-button">
                    	<button class="button emphasized" id="mnist_load">
                            Load Data (<span id="percent">0%</span>)
                        </button>
                        <button class="button-transport" id="mnist_reset"><img src="img/reset.png"></button>
                        <button class="button-transport inactive" id="mnist_start"><img src="img/play.png"></button>
                        <button class="button-transport hidden" id="mnist_stop"><img src="img/pause.png"></button>
                        <button class="button-transport inactive" id="mnist_step"><img src="img/fastforward.png"></button>
                    </div>
                    </br>
                    <label class="viz">
                        Batch: <span id="batch">0</span>
                    </label>
                    <label class="viz">
                        Epoch: <span id="epoch">0</span>
                    </label>
                </div>
            </div>

        </div>
        <div class="container">
	        <div class="column-6-8">
	            <p>As you can see, L1 and L2 regularizations have a dramatic effect on the weights values:</p>
	               </br>
                    <strong>For the L1 regularization: </strong>
                    <ul>
                            <li>“Too small” <script> document.write(katex.renderToString('\\lambda'))</script> constant: there’s no apparent effect.</li>
                            <li>“Appropriate” <script> document.write(katex.renderToString('\\lambda'))</script> constant: many of the weights become zeros. This is called “sparsity of the weights”. Because the weight penalty is independent of the weight values, weights with value 0.001 are penalized just as much as weights with value 1000. The value of the penalty is <script> document.write(katex.renderToString('\\alpha\\lambda'))</script> (generally very small). It constrains the subset of weights that are “less useful to the model” to be equal to 0. For example, you could effectively end up with 200 non-zero weights out of 1,000, which means that 800 weights were less useful for learning the task.</li>
                            <li>“Too large" <script> document.write(katex.renderToString('\\lambda'))</script> constant: You can observe a plateau, which means that the weights uniformly take values around zero. In fact, because <script> document.write(katex.renderToString('\\lambda'))</script> is large, the penalty <script> document.write(katex.renderToString('-\\alpha\\lambda sign(w)'))</script> is much higher than the gradient <script> document.write(katex.renderToString('- \\alpha \\frac{\\partial J_{cross-entropy}}{\\partial w}'))</script>. Thus, at every update, <script> document.write(katex.renderToString('w'))</script> is pushed by <script> document.write(katex.renderToString('\\approx -\\alpha\\lambda sign(w)'))</script> in the opposite direction of its sign. For instance, if <script> document.write(katex.renderToString('w'))</script> is around zero, but slightly positive, then it will be pushed towards <script> document.write(katex.renderToString('-\\alpha\\lambda'))</script> when the penalty is applied. Hence, the plateau’s width should be <script> document.write(katex.renderToString('2 \\times \\alpha\\lambda'))</script>.</li>
                    </ul>


                    <strong>For the L2 regularization: </strong>
                    <ul>


                            <li>“Too small” <script> document.write(katex.renderToString('\\lambda'))</script> constant: there’s no apparent effect.</li>
                            <li>“Appropriate” <script> document.write(katex.renderToString('\\lambda'))</script> constant: the weight values decrease following a centered distribution that becomes more and more peaked throughout training.</li>
                            <li>“Too large” <script> document.write(katex.renderToString('\\lambda'))</script> constant: All the weights are rapidly collapsing to zeros, and the model obviously underfits because the weight values are too constrained.</li>
                    </ul>


                    <p>The weight sparsity effect caused by L1 regularization makes your model more compact in theory, and leads to storage-efficient compact models that are commonly used in smart mobile devices.</p>

	        </div>
            <div class="column-6-8">
                <h3>How do you implement L1 and L2 regularization?</h3>
            </div>
            <div class="column-6-8">
	            <p>Deep learning frameworks such as Keras allow you to add L1 or L2 regularization to your network in one line of code. The difference in the optimization process is implemented automatically. Here's an example: <a href="https://keras.io/regularizers/" target="_blank">L1 and L2 regularization in Keras</a>.</p>
	        </div>
	        <div class="column-6-8">
                <h3>How does weight decay help the model generalize?</h3>
            </div>
	        <div class="column-6-8">
                    <li>Weight decay suppresses any irrelevant components of the weight vector by driving the optimization to find the smallest vector that solves the learning problem.</li>
                    <li>Weight decay attenuates the influence of outliers on the weight optimization by constraining the weight values. There’s less risk for the weights to learn the sampling error (for example when a subset of your data points comes from a wrong distribution or is mislabelled.) In other words, the output of the model is less affected by changes in the input.</li>

                <p>It’s useful to build some intuition about what L1 and L2 regularization do. You can play with the visualization below to observe variations of the cost landscape subject to regularization from a top view.</p>
	        </div>
        </div>
        <div class="full-container hide-backToTop" id="landscape">
            <div class="viz-column-4-8">
                <div id="contour"></div>
            </div>
            <div class="viz-column-3-8">
                <div class="viz-field">
                    <h4>1. Choose an <a href="https://en.wikipedia.org/wiki/Test_functions_for_optimization" target="_blank">artificial</a> loss landscape</h4>

                    <div class="lossFunctions">
                        <label>
                          <input type="radio" name="loss" value="himmelblaus" checked/>
                          <img src="./img/loss/himmelblaus.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="styblinskiTang" />
                          <img src="./img/loss/styblinskiTang.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="mcCormick" />
                          <img src="./img/loss/mcCormick.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="matyas" />
                          <img src="./img/loss/matyas.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="rosenbrock" />
                          <img src="./img/loss/rosenbrock.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="beale" />
                          <img src="./img/loss/beale.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="goldsteinPrice"/>
                          <img src="./img/loss/goldsteinPrice.png">
                        </label>
                        <label>
                          <input type="radio" name="loss" value="rastrigin" />
                          <img src="./img/loss/rastrigin.png">
                        </label>
                    </div>
                </div>

                <div class="viz-field">
                    <h4>2. Select a regularization method</h4>

                    <label class="radio-container">L1 regularization
                        <input type="radio" value="1" name="reg">
                        <span class="checkmark"></span>
                    </label>
                    <label class="radio-container">L2 regularization
                        <input type="radio" value="0" name="reg" checked>
                        <span class="checkmark"></span>
                    </label>
                </div>

                <div class="viz-field">
    	            <h4>3. Choose a value for the regularization constant</h4>

                    <input type="range" value="0" min="0" max="40" step="any" id="lambda">
                    </br>
                    <label>Lambda = <span id="lambda_val">0.00</span></label>
                </div>
            </div>
        </div>
        <div class="container">
	        <div class="column-6-8">
	            <p>As you can see, L1 and L2 regularizations have a dramatic effect on the geometry of the cost function:</p>
	            <ul class="bullet-list">
                    <li>Using the first landscape (Himmelblaus Function), notice that adding L2 regularization prevents the network from converging to a local minimum.</li>
                    <li>Using the last landscape (Rastrigin Function), notice that adding regularization results in a more convex cost landscape and diminishes the chance of falling into a non-desired minimum.</li>
                </ul>
	        </div>
        </div>

        <div class="container">
            <div class="column-6-8 column-align divider-bottom index4-target">
                <h3>IV&emsp; Dropout regularization</h3>
                <p>Although L1 and L2 regularization are simple techniques to reducing overfitting, there exist other methods, such as dropout regularization, that have been shown to be more effective at regularizing larger and more complex networks. <span class="marginanchor" id="margin-17-anchor" data-number="17" data-align="middle">If you had unlimited computational power</span>, you could improve generalization by averaging the predictions of several different neural networks trained on the same task. The combination of these models will likely perform better than a single neural network trained on this task. However, with deep neural networks, training various architectures is expensive because:</p>

                <ul>
             		<li>Tuning the hyperparameters is time consuming.</li>
             		<li>Training the networks requires a lot of computations.</li>
             		<li>You need a large amount of data to train the models on different subsets of the data.</li>
             	</ul>

                <p>Dropout is a regularization technique, introduced in <a href="http://jmlr.org/papers/volume15/srivastava14a.old/srivastava14a.pdf" target="_blank">Srivastava et al. (2014)</a>, that allows you to combine many different architectures efficiently by randomly dropping some of the neurons of your network during training.</p>
            	<!-- <video width="70%" height="auto" controls>
					<source src="img/dropout1.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video> -->
                <div id="dropout-placeholder"></div>
            	<p>Dropout is discussed in detail in our <a href="https://www.coursera.org/specializations/deep-learning" target="_blank">Deep Learning Specialization</a> (<a href="https://www.coursera.org/learn/deep-neural-network" target="_blank">Course 2: “Improving Neural Networks”</a>, Week 2: “Practical aspects of Deep Learning”). We invite you to check it out to understand the intuition behind dropout. </p>
            </div>
            <div class="column-2-8 column-align margin">
                <div class="marginbody" id="margin-17-body" data-number="17">
                    <p class="caption">This, in fact, is the motivation behind ensemble methods such as random forest.</p>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="column-6-8">
                <h3>Conclusion</h3>
            </div>
            <div class="column-6-8">
                <p>When applying regularization methods, you need a metric to track your model's improvement and generalization ability. The bias/variance tradeoff enables you to measure the efficiency of your regularization. <p>The bias/variance tradeoff is discussed in our <a href="https://www.coursera.org/specializations/deep-learning" target="_blank">Deep Learning Specialization</a> (<a href="https://www.coursera.org/learn/deep-neural-network" target="_blank">Course 2: “Improving Neural Networks”</a>, Week 2: “Practical aspects of Deep Learning”). We invite you to check it out! </p>


                <p>Successfully training a model on complex tasks is complicated. You need to find a model architecture that can encompass the complexity of the dataset. Once you find such an architecture, you can work on improving generalization. Exploring, and even combining, different regularization techniques is an unmissable step of the training process. It helps you build intuition on the ability of a model to generalize in the real-world.</p>
            </div>
        </div>

    </div>

    <div class="footer">
        <div class="container">
            <div class="column-2-8 column-align">
                <h4 class="reference">Authors</h4>
            </div>
            <div class="column-6-8 column-align">
                <ol class="reference ">
                    <li><a href="https://twitter.com/kiankatan">Kian Katanforoosh</a> - Written content and structure. </li>
                    <li><a href="http://daniel-kunin.com">Daniel Kunin</a> - Visualizations (created using <a href="https://d3js.org/">D3.js</a> and <a href="https://js.tensorflow.org/">TensorFlow.js</a>).</li>
                </ol>
            </div>
            <div class="column-2-8 column-align">
                <h4 class="reference">Acknowledgments</h4>
            </div>
            <div class="column-6-8 column-align">
                <ol class="reference">
                    <li>The template for the article was designed by <a href="https://www.jingru-guo.com/">Jingru Guo</a> and inspired by <a href="https://distill.pub/">Distill</a>.</li>
                    <li>The loss landscape visualization adapted code from Mike Bostock's <a href="https://bl.ocks.org/mbostock/f48ff9c1af4d637c9a518727f5fdfef5">visualization</a> of the Goldstein-Price function.</li>
                    <li>The banner visualization adapted code from deeplearn.js's implementation of a <a href="https://deeplearnjs.org/demos/nn-art/">CPPN</a>.</li>
                </ol>
            </div>
            <div class="column-2-8 column-align">
                <h4 class="reference">Footnotes</h4>
            </div>
            <div class="column-6-8 column-align">
                <ol class="reference footnote">
                    <li class="footnote-index1-target"><a href="https://papers.nips.cc/paper/563-a-simple-weight-decay-can-improve-generalization.pdf">A Simple Weight Decay Can Improve Generalization</a></li>
                    <li class="footnote-index2-target"><a href="https://www.coursera.org/learn/neural-networks/lecture/n6TUy/the-bayesian-interpretation-of-weight-decay-11-min">The Bayesian interpretation of weight decay</a></li>
                    <li class="footnote-index3-target"><a href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li>
                    <li class="footnote-index4-target"><a href="https://arxiv.org/pdf/1802.01223.pdf">Learning Compact Neural Networks with Regularization</a></li>
                </ol>
            </div>
            <div class="column-2-8 column-align">
                <h4 class="reference">Reference</h4>
            </div>
            <div class="column-6-8 column-align">
                <p class="reference">To reference this article in an academic context, please cite this work as:</p>
                <p class="citation">Katanforoosh & Kunin, "Regularizing your neural networks", deeplearning.ai, 2018.</p>
                <!-- <p class="reference">BibTeX citation:</p>
                <p class="citation">@article{kiank+dkunin,<br>
                  &emsp;author = {Katanforoosh, Kian and Kunin, Daniel},<br>
                  &emsp;title = {Initializing your neural networks},<br>
                  &emsp;journal = {deeplearning.ai},<br>
                  &emsp;year = {2018}}</p> -->
            </div>
        </div>
    </div>
    <div class="footer-generic hide-backToTop">
        <div class="container">
            <p class="footer-note">
                Contact us at hello@deeplearning.ai</br>
                © Deeplearning.ai 2018</br>
                <a href="https://www.deeplearning.ai/privacy/">PRIVACY POLICY</a> <a href="https://www.deeplearning.ai/terms-of-use/">TERMS OF USE</a>
            </p>



            <div class="social">
                    <a href="https://www.facebook.com/deeplearningHQ/"><i class="fab fa-facebook fontAwesomeIcon" ></i></a>
                    <a href="https://twitter.com/deeplearningai_"><i class="fab fa-twitter-square fontAwesomeIcon"></i></a>
                    <a href="https://www.linkedin.com/company/deeplearningai/"><i class="fab fa-linkedin fontAwesomeIcon"></i></a>
            </div>
        </div>
    </div>
    <div class="backToTop">
        <p>↑ Back to top</p>
    </div>
</body>

<!-- EARLY STOPPING & DROPOUT -->
<link rel="stylesheet" href="css/earlystopping.css">
<script src="js/TweenMax.min.js"></script>
<script src="js/Draggable.min.js"></script>
<script src="js/DrawSVGPlugin.min.js"></script>
<script src="js/MorphSVGPlugin.min.js"></script>
<script src="js/snap.svg-min.js"></script>
<script src="js/earlystopping.js"></script>
<script src="js/dropout.js"></script>

<!-- LANDSCAPE -->
<script src="https://d3js.org/d3-contour.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
<link rel="stylesheet" href="css/landscape.css">
<script src="js/landscape/loss.js"></script>
<script src="js/landscape/viz.js"></script>

<!-- SPARSITY -->
<link rel="stylesheet" href="css/sparsity.css">
<script src="js/sparsity/nn.js"></script>
<script src="js/sparsity/zip/zip.js"></script>
<script src="js/sparsity/zip/zip-ext.js"></script>
<script src="js/sparsity/data.js"></script>
<script src="js/sparsity/viz.js"></script>

<!-- CPPN -->
<script src="js/cppn.js"></script>
